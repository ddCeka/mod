
init 2 python in mod:
    _constant = True

    class ChoicesClass(NonPicklable):
        @property
        def isDisplayingChoice(self):
            try:
                current = renpy.game.context().current
                script = renpy.game.script.lookup(current)
                return isinstance(script, renpy.ast.Menu)
            except:
                return False
        
        @property
        def currentChoices(self):
            try:
                current = renpy.game.context().current
                script = renpy.game.script.lookup(current)
                if isinstance(script, renpy.ast.Menu): 
                    choices = []
                    for i,item in enumerate(script.items):
                        if len(item) >= 3 and item[2]:
                            choices.append(modChoice(i, item))
                    return choices
            except:
                pass
        
        @property
        def hiddenCount(self):
            count = 0
            for choice in self.currentChoices or []:
                if not choice.isVisible:
                    count += 1
            return count

    class modChoice(NonPicklable):
        """
        The tuple exists of 3 items
        0: The text
        1: Condition
        2: Choice content in a list
        """
        def __init__(self, index, choiceTuple):
            self._m1_choices__index = index
            self._m1_choices__choice = choiceTuple
            self._m1_choices__code = None
            self._m1_choices__jumpTo = None
        
        @property
        def isVisible(self):
            """ Is this choice available? """
            return eval(self.condition, renpy.store.__dict__)
        
        @property
        def text(self):
            """ Get the option text (not translated!) """
            try:
                return renpy.exports.substitute(self._m1_choices__choice[0])
            except:
                return self._m1_choices__choice[0]
        
        @property
        def condition(self):
            return self._m1_choices__choice[1]
        
        @property
        def code(self):
            if self._m1_choices__code == None:
                try:
                    self._m1_choices__code = CodeView.nodesToCode(self._m1_choices__choice[2])
                except Exception as e:
                    print(': PathDetection: Failed to generate choice code. {}'.format(e))
                    self._m1_choices__code = '# Failed to generate code'
            return self._m1_choices__code
        
        @property
        def jumpTo(self):
            if self._m1_choices__jumpTo == None:
                self._m1_choices__jumpTo = ''
                for content in self._m1_choices__choice[2]:
                    if isinstance(content, renpy.ast.Jump):
                        self._m1_choices__jumpTo = content.target
                        break
            return self._m1_choices__jumpTo
        
        @property
        def Action(self):
            def choose():
                renpy.game.log.rollback_is_fixed = False
                return renpy.ui.ChoiceReturn(self._m1_choices__choice[0], self._m1_choices__index)()
            
            return choose
        
        @property
        def OpenCodeView(self):
            class OpenCodeViewAction():
                def __init__(self, choice):
                    self.choice = choice
                
                def __call__(self):
                    renpy.show_screen(
                        'mod_CodeView',
                        code=self.choice.code,
                        title='{mod_notl}Choice code{/mod_notl}',
                        details='The code shown here is generated by mod, it\'s probably not the exact same as what was written by the developer.\n\nSome things about this code view:\n- Variables and labels are clickable to get options\n- If statements are evaluated and a comment is added to show you if the condition is met',
                        detailsTitle='Choice code explanation',
                    )
                    renpy.restart_interaction()
            
            return OpenCodeViewAction(self)
        
        @property
        def OpenConditionView(self):
            class OpenConditionViewAction():
                def __init__(self, choice):
                    self.choice = choice
                
                def __call__(self):
                    renpy.show_screen(
                        'mod_CodeView',
                        code=self.choice.condition,
                        title='{mod_notl}Visibility condition{/mod_notl}',
                    )
                    renpy.restart_interaction()
            
            return OpenConditionViewAction(self)
